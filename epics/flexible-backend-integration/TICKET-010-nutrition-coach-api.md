# TICKET-010: Nutrition Coach API

**Priority**: Medium  
**Estimate**: 5-7 hours  
**Dependencies**: TICKET-009 (Intent Classification), TICKET-002 (Core Types)  
**Assignee**: TBD  

## Description
Create a dedicated API endpoint for nutrition coaching that analyzes user context, generates personalized advice, and creates actionable recommendations. This API uses web search for research and provides evidence-based guidance.

## Acceptance Criteria
- [ ] `/api/chat/nutrition-coach` endpoint created
- [ ] Context gathering from user's nutrition data
- [ ] Web search integration for research
- [ ] Structured coaching responses with recommendations
- [ ] Sources attribution for all advice
- [ ] Conversation history tracking
- [ ] Error handling and validation

## Files to Create/Modify
- `src/app/api/chat/nutrition-coach/route.ts` (new)
- `src/lib/ai/coachingPrompts.ts` (new)
- `src/lib/ai/contextGathering.ts` (new)
- `src/lib/ai/recommendationGenerator.ts` (new)

## Implementation Details

### 1. Main API Endpoint
```typescript
// src/app/api/chat/nutrition-coach/route.ts
import { NextRequest } from 'next/server'
import { generateObject } from 'ai'
import { createOpenRouter } from '@openrouter/ai-sdk-provider'
import { tavily } from '@tavily/core'
import { z } from 'zod'
import { auth } from '@clerk/nextjs'
import { getCurrentBackend } from '@/lib/BackendFactory'
import { gatherUserContext } from '@/lib/ai/contextGathering'
import { generateCoachingResponse } from '@/lib/ai/recommendationGenerator'
import { NUTRITION_COACH_PROMPT, buildCoachingPrompt } from '@/lib/ai/coachingPrompts'
import { CoachingResponse } from '@/lib/types'

const openrouter = createOpenRouter({
  apiKey: process.env.OPENROUTER_API_KEY,
})

const tvly = tavily({
  apiKey: process.env.TAVILY_API_KEY,
})

const coachingModel = openrouter.chat('anthropic/claude-3-haiku')

export async function POST(req: NextRequest) {
  try {
    const { message } = await req.json()
    const { userId } = auth()

    if (!userId) {
      return Response.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (!message || typeof message !== 'string') {
      return Response.json({ error: 'Message is required' }, { status: 400 })
    }

    const startTime = Date.now()
    const backend = getCurrentBackend()

    // 1. Gather comprehensive user context
    const userContext = await gatherUserContext(userId, backend)

    // 2. Determine if web search is needed
    const needsResearch = await shouldPerformWebSearch(message, userContext)
    let searchResults = null

    if (needsResearch) {
      // 3. Perform targeted web search
      const searchQuery = buildSearchQuery(message, userContext)
      searchResults = await tvly.search(searchQuery, {
        maxResults: 5,
        searchDepth: 'advanced',
        topic: 'general',
      })
    }

    // 4. Generate comprehensive coaching response
    const coachingResponse = await generateCoachingResponse(
      message,
      userContext,
      searchResults?.results || []
    )

    // 5. Save conversation to backend
    const conversation = await backend.saveCoachingConversation(userId, {
      id: '', // Will be generated by backend
      userId,
      userMessage: message,
      assistantResponse: coachingResponse.response,
      context: userContext,
      recommendations: coachingResponse.recommendations,
      sources: coachingResponse.sources,
      responseTimeMs: Date.now() - startTime,
      modelUsed: 'anthropic/claude-3-haiku',
      timestamp: new Date()
    })

    // 6. Save recommendations for user approval
    if (coachingResponse.recommendations?.length > 0) {
      for (const rec of coachingResponse.recommendations) {
        await backend.saveNutritionRecommendation(userId, {
          ...rec,
          conversationId: conversation.id
        })
      }
    }

    return Response.json({
      response: coachingResponse.response,
      recommendations: coachingResponse.recommendations,
      sources: coachingResponse.sources,
      conversationId: conversation.id
    })

  } catch (error) {
    console.error('Nutrition coaching error:', error)
    return Response.json(
      { error: 'Failed to generate coaching response' },
      { status: 500 }
    )
  }
}

/**
 * Determine if web search is needed based on the query
 */
async function shouldPerformWebSearch(message: string, context: any): Promise<boolean> {
  const researchIndicators = [
    'research', 'studies', 'evidence', 'latest',
    'new study', 'recent findings', 'scientific',
    'supplements', 'specific nutrient', 'condition',
    'medical', 'health issue', 'disorder'
  ]

  const messageWords = message.toLowerCase()
  const needsResearch = researchIndicators.some(indicator => 
    messageWords.includes(indicator)
  )

  // Also search if user is asking about complex nutrition topics
  const complexTopics = [
    'metabolism', 'hormone', 'thyroid', 'insulin',
    'micronutrient', 'deficiency', 'allergy',
    'inflammatory', 'gut health', 'absorption'
  ]

  const isComplexTopic = complexTopics.some(topic => 
    messageWords.includes(topic)
  )

  return needsResearch || isComplexTopic
}

/**
 * Build targeted search query based on user message and context
 */
function buildSearchQuery(message: string, context: any): string {
  const baseQuery = `nutrition ${message}`
  
  // Add context-specific terms
  let contextTerms = []
  
  if (context.recentConcerns?.includes('energy')) {
    contextTerms.push('energy levels fatigue')
  }
  
  if (context.recentConcerns?.includes('weight')) {
    contextTerms.push('weight management')
  }
  
  if (context.currentTargets) {
    contextTerms.push('macro tracking')
  }

  return contextTerms.length > 0 
    ? `${baseQuery} ${contextTerms.join(' ')}`
    : baseQuery
}
```

### 2. Coaching Prompts
```typescript
// src/lib/ai/coachingPrompts.ts
export const NUTRITION_COACH_PROMPT = `You are an expert nutritionist and wellness coach with 15+ years of experience. You provide evidence-based, personalized nutrition guidance.

Core Principles:
1. Always base recommendations on scientific evidence
2. Consider the individual's complete context (meals, targets, trends, concerns)
3. Provide actionable, specific advice
4. Explain the reasoning behind recommendations
5. Be encouraging and supportive
6. Acknowledge when medical consultation is needed

Response Guidelines:
- Keep responses conversational and empathetic
- Use data from the user's nutrition tracking to personalize advice
- Provide specific, measurable recommendations when appropriate
- Always cite sources for scientific claims
- Consider sustainability and lifestyle factors
- Address both immediate concerns and long-term goals`

export function buildCoachingPrompt(
  userMessage: string,
  userContext: any,
  searchResults: any[] = []
): string {
  const prompt = `${NUTRITION_COACH_PROMPT}

USER CONTEXT:
${formatUserContext(userContext)}

${searchResults.length > 0 ? `RESEARCH RESULTS:
${formatSearchResults(searchResults)}` : ''}

USER MESSAGE: "${userMessage}"

TASK: Analyze the user's message in the context of their nutrition data and provide helpful coaching advice.

Consider:
1. Are their current targets appropriate for their goals?
2. Do their recent meals and patterns suggest any adjustments?
3. How does their concern relate to their nutrition data?
4. What specific, actionable advice can you provide?
5. Should targets be adjusted based on their feedback?

Response Format:
{
  "response": "Your conversational response to the user (2-3 paragraphs)",
  "needsTargetAdjustment": boolean,
  "recommendations": [
    {
      "type": "target_adjustment" | "meal_suggestion" | "lifestyle_change",
      "title": "Brief title (under 50 chars)",
      "description": "Detailed description of the recommendation",
      "reasoning": "Scientific reasoning with evidence",
      "currentTargets": { current target values if applicable },
      "proposedTargets": { new target values if applicable },
      "confidence": 75 // 0-100 based on evidence strength
    }
  ],
  "sources": [
    {
      "title": "Source title",
      "url": "https://...",
      "domain": "domain.com",
      "relevance": "high" | "medium" | "low",
      "type": "research" | "guideline" | "expert_opinion"
    }
  ]
}`

  return prompt
}

function formatUserContext(context: any): string {
  let formatted = ''
  
  if (context.currentTargets) {
    formatted += `Current Targets:
- Daily Calories: ${context.currentTargets.dailyCalories}
- Protein: ${context.currentTargets.targetProtein}g
- Carbs: ${context.currentTargets.targetCarbs}g  
- Fat: ${context.currentTargets.targetFat}g
- Last adjusted: ${context.currentTargets.lastAdjustedBy || 'user'}

`
  }

  if (context.nutritionSummary) {
    formatted += `Today's Intake:
- Calories: ${context.nutritionSummary.calories}
- Protein: ${context.nutritionSummary.protein}g
- Carbs: ${context.nutritionSummary.carbs}g
- Fat: ${context.nutritionSummary.fat}g

`
  }

  if (context.trends?.length > 0) {
    formatted += `Recent Trends (last 7 days):
- Average calories: ${Math.round(context.trends.reduce((sum, day) => sum + day.calories, 0) / context.trends.length)}
- Average adherence: ${Math.round(context.trends.reduce((sum, day) => sum + day.adherenceScore, 0) / context.trends.length)}%
- Days logged: ${context.trends.length}

`
  }

  if (context.recentMeals?.length > 0) {
    formatted += `Recent Meals (last 3 days):
${context.recentMeals.slice(0, 5).map(meal => 
  `- ${meal.name} (${meal.nutritionData?.calories || '?'} cal)`
).join('\n')}

`
  }

  return formatted
}

function formatSearchResults(results: any[]): string {
  return results.slice(0, 3).map((result, index) => 
    `${index + 1}. ${result.title}
   ${result.content}
   Source: ${result.url}
`
  ).join('\n')
}
```

### 3. Context Gathering
```typescript
// src/lib/ai/contextGathering.ts
import { NutritionDataAccess } from '@/lib/interfaces/NutritionDataAccess'
import { 
  NutritionTargets, 
  NutritionSummary, 
  NutritionTrend,
  RecordedMeal 
} from '@/lib/types'

export interface UserNutritionContext {
  currentTargets: NutritionTargets | null
  nutritionSummary: NutritionSummary
  trends: NutritionTrend[]
  recentMeals: RecordedMeal[]
  adherencePattern: 'consistent' | 'inconsistent' | 'new_user'
  recentConcerns: string[]
  goalProgress: {
    calorieAdherence: number
    macroBalance: number
    consistencyScore: number
  }
}

export async function gatherUserContext(
  userId: string,
  backend: NutritionDataAccess
): Promise<UserNutritionContext> {
  try {
    // Gather all relevant data in parallel
    const [targets, summary, trends, recentMeals] = await Promise.all([
      backend.getNutritionTargets(userId),
      backend.getTodaysNutritionSummary(userId),
      backend.getNutritionTrends(userId, 14), // Last 2 weeks
      backend.getMealsByDateRange(
        userId,
        new Date(Date.now() - 3 * 24 * 60 * 60 * 1000), // Last 3 days
        new Date()
      )
    ])

    // Analyze patterns and calculate metrics
    const adherencePattern = analyzeAdherencePattern(trends)
    const recentConcerns = inferRecentConcerns(trends, recentMeals)
    const goalProgress = calculateGoalProgress(trends, targets)

    return {
      currentTargets: targets,
      nutritionSummary: summary,
      trends,
      recentMeals,
      adherencePattern,
      recentConcerns,
      goalProgress
    }
  } catch (error) {
    console.error('Error gathering user context:', error)
    
    // Return minimal context on error
    return {
      currentTargets: null,
      nutritionSummary: { calories: 0, protein: 0, carbs: 0, fat: 0 },
      trends: [],
      recentMeals: [],
      adherencePattern: 'new_user',
      recentConcerns: [],
      goalProgress: {
        calorieAdherence: 0,
        macroBalance: 0,
        consistencyScore: 0
      }
    }
  }
}

function analyzeAdherencePattern(trends: NutritionTrend[]): 'consistent' | 'inconsistent' | 'new_user' {
  if (trends.length < 3) return 'new_user'
  
  const adherenceScores = trends.map(t => t.adherenceScore).filter(score => score > 0)
  if (adherenceScores.length === 0) return 'new_user'
  
  const variance = calculateVariance(adherenceScores)
  const average = adherenceScores.reduce((sum, score) => sum + score, 0) / adherenceScores.length
  
  // High variance = inconsistent, low variance = consistent
  if (variance > 400 || average < 50) return 'inconsistent'
  return 'consistent'
}

function inferRecentConcerns(trends: NutritionTrend[], meals: RecordedMeal[]): string[] {
  const concerns: string[] = []
  
  // Check for low calorie patterns
  const avgCalories = trends.reduce((sum, t) => sum + t.calories, 0) / trends.length
  if (avgCalories < 1200) {
    concerns.push('low_calories')
  }
  
  // Check for meal timing issues
  const morningMeals = meals.filter(meal => {
    const hour = new Date(meal.timestamp).getHours()
    return hour >= 6 && hour <= 10
  })
  
  if (morningMeals.length < meals.length * 0.3) {
    concerns.push('irregular_eating')
  }
  
  // Check for macro imbalances
  const avgProtein = trends.reduce((sum, t) => sum + t.protein, 0) / trends.length
  if (avgProtein < 50) {
    concerns.push('low_protein')
  }
  
  return concerns
}

function calculateGoalProgress(trends: NutritionTrend[], targets: NutritionTargets | null) {
  if (!targets || trends.length === 0) {
    return { calorieAdherence: 0, macroBalance: 0, consistencyScore: 0 }
  }
  
  const calorieAdherence = trends.reduce((sum, t) => sum + t.adherenceScore, 0) / trends.length
  
  // Calculate macro balance (how close to target ratios)
  const avgCalories = trends.reduce((sum, t) => sum + t.calories, 0) / trends.length
  const proteinRatio = (trends.reduce((sum, t) => sum + t.protein, 0) / trends.length * 4) / avgCalories
  const targetProteinRatio = (targets.targetProtein * 4) / targets.dailyCalories
  
  const macroBalance = Math.max(0, 100 - Math.abs(proteinRatio - targetProteinRatio) * 1000)
  
  // Consistency score based on variance
  const calories = trends.map(t => t.calories)
  const consistencyScore = Math.max(0, 100 - calculateVariance(calories) / 1000)
  
  return {
    calorieAdherence: Math.round(calorieAdherence),
    macroBalance: Math.round(macroBalance),
    consistencyScore: Math.round(consistencyScore)
  }
}

function calculateVariance(numbers: number[]): number {
  const mean = numbers.reduce((sum, num) => sum + num, 0) / numbers.length
  const squaredDiffs = numbers.map(num => Math.pow(num - mean, 2))
  return squaredDiffs.reduce((sum, diff) => sum + diff, 0) / numbers.length
}
```

### 4. Recommendation Generator
```typescript
// src/lib/ai/recommendationGenerator.ts
import { generateObject } from 'ai'
import { createOpenRouter } from '@openrouter/ai-sdk-provider'
import { z } from 'zod'
import { buildCoachingPrompt } from './coachingPrompts'
import { CoachingResponse, NutritionSource } from '@/lib/types'
import { UserNutritionContext } from './contextGathering'

const openrouter = createOpenRouter({
  apiKey: process.env.OPENROUTER_API_KEY,
})

const coachingModel = openrouter.chat('anthropic/claude-3-haiku')

const coachingResponseSchema = z.object({
  response: z.string(),
  needsTargetAdjustment: z.boolean(),
  recommendations: z.array(z.object({
    type: z.enum(['target_adjustment', 'meal_suggestion', 'lifestyle_change']),
    title: z.string(),
    description: z.string(),
    reasoning: z.string(),
    currentTargets: z.any().optional(),
    proposedTargets: z.any().optional(),
    confidence: z.number().min(0).max(100)
  })),
  sources: z.array(z.object({
    title: z.string(),
    url: z.string(),
    domain: z.string(),
    relevance: z.enum(['high', 'medium', 'low']),
    type: z.enum(['research', 'guideline', 'expert_opinion'])
  }))
})

export async function generateCoachingResponse(
  userMessage: string,
  userContext: UserNutritionContext,
  searchResults: any[] = []
): Promise<CoachingResponse> {
  try {
    const prompt = buildCoachingPrompt(userMessage, userContext, searchResults)
    
    const result = await generateObject({
      model: coachingModel,
      schema: coachingResponseSchema,
      prompt,
      maxTokens: 2000
    })

    // Process and enhance the response
    const response = result.object
    
    // Add IDs to recommendations
    const recommendations = response.recommendations.map((rec, index) => ({
      id: `temp_${Date.now()}_${index}`,
      userId: '', // Will be set by the API
      ...rec,
      status: 'pending' as const,
      createdAt: new Date()
    }))

    // Process sources from search results
    const sources = processSources(response.sources, searchResults)

    return {
      response: response.response,
      needsTargetAdjustment: response.needsTargetAdjustment,
      recommendations,
      sources
    }
  } catch (error) {
    console.error('Error generating coaching response:', error)
    
    // Fallback response
    return {
      response: "I'm having trouble analyzing your situation right now. Could you try rephrasing your question? I'm here to help with your nutrition goals.",
      needsTargetAdjustment: false,
      recommendations: [],
      sources: []
    }
  }
}

function processSources(aiSources: any[], searchResults: any[]): NutritionSource[] {
  const processed: NutritionSource[] = []
  
  // Match AI-selected sources with search results
  for (const aiSource of aiSources) {
    const matchingResult = searchResults.find(result => 
      result.url === aiSource.url || 
      result.title.toLowerCase().includes(aiSource.title.toLowerCase())
    )
    
    if (matchingResult) {
      processed.push({
        title: matchingResult.title,
        url: matchingResult.url,
        domain: new URL(matchingResult.url).hostname,
        snippet: matchingResult.content?.substring(0, 200),
        relevance: aiSource.relevance,
        type: aiSource.type
      })
    }
  }
  
  return processed
}
```

## Error Handling & Validation
- Request validation for required fields
- User authentication via Clerk
- Graceful fallbacks for AI failures
- Rate limiting to prevent abuse
- Input sanitization

## Performance Optimizations
- Parallel data gathering for user context
- Efficient database queries
- Response caching for similar queries
- Connection pooling for database
- Timeout handling for AI requests

## Testing Requirements
- Unit tests for all functions
- Integration tests with real user data
- Performance testing for response times
- Error scenario testing
- Load testing for concurrent users

## Security Considerations
- User data isolation via RLS
- Input validation and sanitization
- Rate limiting for API calls
- Secure handling of search results
- Error message sanitization

## Definition of Done
- [ ] API endpoint fully functional
- [ ] Context gathering comprehensive
- [ ] Coaching responses high quality
- [ ] Web search integration working
- [ ] Conversation history saved
- [ ] Error handling robust
- [ ] Performance optimized
- [ ] Security measures implemented
- [ ] Tests passing
- [ ] Code review approved